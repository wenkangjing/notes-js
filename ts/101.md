# TypeScript 101

https://www.typescriptlang.org/docs

## TL;DR
- superset of JS
- interface/class
- import/export
- module/namespace
- public/private
- type : and cast <>

```
module/namespace  --> class  --> fields / constructor / properties / functions
                        |
                        V
                    interface
```

## Types

### Primitive Types
- `boolean`
- `number`
- `string`

### Array

```typescript
let numArr: number [] = [1, 2, 3];
let strArr: string [] = ['hi', 'hey'];

```

### Enum
- same as other lang, starts with 0 by default

```typescript
enum Color { Red = 1, Green, Blue }
let c: Color = Color.Green;
```

### Object
- non-primitive type, i.e. any thing that is not `number`, `string`, `boolean`, `symbol`, `null`, or `undefined`

### Special Types

`any` - **new**
- escape the type system
- opt-out type checking


`undefined` and `null`
- same as javascript
- can assign to any type

### Types for Functions

`never` - **new**
- a **function** that always throws an exception
- no return point in a function

`void` - **new**
- a function that returns nothing

### Type Cast
- `(<string>myAny).length`
- `(myAny as string).length`

### Generic

aka template `Array<T>`,

### Union Type
- multiple types but don't want use `any` instead use `|` to pipe all possible types
- e.g. `function formatCommandline(command: string[]|string)`

### Tuple

```typescript
let x: [number, string];
x = [1, 'Jamie'];
```

### Type Alias

type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) => void;

>TIP: If you need to have hierarchies of Type annotations use an interface. They can be used with implements and extends

>TIP: Use a type alias for simpler object structures (like Coordinates) just to give them a semantic name. Also when you want to give semantic names to Union or Intersection types, a Type alias is the way to go.

`var` or `let`
- `let` block scope
- `let` stop you re declare in the same scope

## Functions

a function returns `never` - return nothing, not even `undefined` or `null`

a function returns `void` - it still can return `undefined` or `null`

>MY TIP: Should always prefer `never` on function return

## Interfaces

a simple data structure, or sub type helping tsc to do the type checking

- property modifiers

```typescript
interface {
    firstname: string;
    lastname: string;
    readonly dob: string; // can never be modified
    nickname? string; // optional

}
```

- How interface help to do the type checking

```typescript
interface IConfig {
    size: number;
}

function foo(config: IConfig) {
    console.log()
}
let ret = foo({ size: 10 } as IConfig); // check the input parameters
```
## Class

- a class extend a interface, like C# Java
- a interface extend another interface

OOP same as other langs
- `static` and `instance`
- `abstract class` // can have impl, only abstract methods to be impl. in derived class
- `public`, `private`, `protected`
- `Readonly`
- `get`, `set` // I have to write my get and set methods, err...

## Module

### export = / import from

- Named Export

```typescript
export const BATCH_SIZE = 10
import { BATCH_SIZE } from 'path/file'
```

- Default Export

```typescript
export default class Dog {}
import Dog from 'filepath'
```

- Mixed

```typescript
export default function foo() {}
export const name = 'Jamie'
import foo, { name } from 'filepath'
```

- Namespace

```typescript
export function add { }
export function sum { }
export function valid { }

import * as helper from "./filepath";
helper.add();
```

- Empty

```typescript
import 'mocha'; //no export only side effect
describe('shortestPath', () => {});

import 'core-js'; // a common polyfill library
```

### export/require

NodeJS - CommonJS Module standard, `module.exports`

export in JS

```JS
exports.equal = function equal
```
in JS

```javascript
const assert = require('assert');
```

To let TS find the type definition file using

```typescript
import * as assert from 'assert';
// or
import { equal } from 'assert';
```

`import/require` for importing type only

```typescript
import foo = require('foo');
```





### export = / import = require()

`import/require` or `import/from`??
- `import/require` to import type
- `import/from` local module


`import = require()`