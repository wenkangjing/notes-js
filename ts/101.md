# TypeScript 101

https://www.typescriptlang.org/docs

## TL;DR
- superset of JS
- interface/class
- import/export
- module/namespace
- public/private
- type : and cast <>

```
module/namespace  --> class  --> fields / constructor / properties / functions
                        |
                        V
                    interface
```

## Types

### Primitive Types
- `boolean`
- `number`
- `string`

### Array

```typescript
let numArr: number [] = [1, 2, 3];
let strArr: string [] = ['hi', 'hey'];

```

### Enum
- same as other lang, starts with 0 by default

```typescript
enum Color { Red = 1, Green, Blue }
let c: Color = Color.Green;
```

### Object
- non-primitive type, i.e. any thing that is not `number`, `string`, `boolean`, `symbol`, `null`, or `undefined`

### Special Types

`any` - **new**
- escape the type system
- opt-out type checking


`undefined` and `null`
- same as javascript
- can assign to any type

### Types for Functions

`never` - **new**
- a **function** that always throws an exception
- no return point in a function

`void` - **new**
- a function that returns nothing

### Type Cast
- `(<string>myAny).length`
- `(myAny as string).length`

### Generic

aka template `Array<T>`,

### Union Type
- multiple types but don't want use `any` instead use `|` to pipe all possible types
- e.g. `function formatCommandline(command: string[]|string)`

### Tuple

```typescript
let x: [number, string];
x = [1, 'Jamie'];
```

### Type Alias

type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) => void;

>TIP: If you need to have hierarchies of Type annotations use an interface. They can be used with implements and extends

>TIP: Use a type alias for simpler object structures (like Coordinates) just to give them a semantic name. Also when you want to give semantic names to Union or Intersection types, a Type alias is the way to go.

`var` or `let`
- `let` block scope
- `let` stop you re declare in the same scope

## Functions

a function returns `never` - return nothing, not even `undefined` or `null`

a function returns `void` - it still can return `undefined` or `null`

>MY TIP: Should always prefer `never` on function return

## Interfaces

a simple data structure, or sub type helping tsc to do the type checking

- property modifiers

```typescript
interface {
    firstname: string;
    lastname: string;
    readonly dob: string; // can never be modified
    nickname? string; // optional

}
```

- How interface help to do the type checking

```typescript
interface IConfig {
    size: number;
}

function foo(config: IConfig) {
    console.log()
}
let ret = foo({ size: 10 } as IConfig); // check the input parameters
```
## Class

- a class extend a interface, like C# Java
- a interface extend another interface

OOP same as other langs
- `static` and `instance`
- `abstract class` // can have impl, only abstract methods to be impl. in derived class
- `public`, `private`, `protected`
- `Readonly`
- `get`, `set` // I have to write my get and set methods, err...


## Library

```
AMD - Front End   \
                   ---> UMD - Universal Module Definition (support both)
CommonJS - NodeJS /
```

### Global Library

>MY TIP: to extend `document` or `window` in Browser or `global` in NodeJS

- Top-level `var` statements or `function` declarations
- One or more assignments to `window.someName`
- Assumptions that `DOM` primitives like `document` or `window` exist
- e.g. jQuery - expose a global variable $ for

In FE

```html
<script src="http://a.great.cdn.for/someLib.js"></script>
```

In Node
```typescript
require("magic-string-time"); // side effects only
```

### Modular Library

Some libraries only work in a module loader environment. For example, because `express` only works in Node.js and must be loaded using the CommonJS `require` function.

The old way to require a library

``` typescript
var fs = require("fs");
```

In **TypeScript or ES6**, the `import` keyword serves the same purpose:

```typescript
import fs = require("fs");
```

## Module

https://www.typescriptlang.org/docs/handbook/module-resolution.html

How compiler resolve a module? Need to answer 2 questions

- what an import refers to? --> moduleA or moduleB
- whatâ€™s the shape of `moduleA`? --> `.ts/.tsx` files, or in a `.d.ts`

### Resolving Process

1. locate the module
2. relative module (your own modules)
3. ambient module declaration (external dependencies)
4. resolved or error TS2307: Cannot find module 'moduleA'.

### Classic Resolve strategy (default, backward compatibility)

- relative -> `path/moduleB.ts` `path/moduleB.d.ts`
- non-relative -> looking up till base

### Node Resolve strategy (`require(./moduleB)`)

relative
  - `./`
  - if there is `main` in `./package.json`, refers to the main
  - if there is `index.js`, implicitly main

non-relative
  - walk up the directory chain
  - looking through each `node_modules` until it finds the module you tried to load.

### How TypeScript resolves modules (The Node Way)

### export / import x from ''

- Named Export

```typescript
export const BATCH_SIZE = 10
import { BATCH_SIZE } from 'path/file'
```

- Default Export

```typescript
export default class Dog {}
import Dog from 'filepath'
```

- Mixed

```typescript
export default function foo() {}
export const name = 'Jamie'
import foo, { name } from 'filepath'
```

- Namespace

```typescript
export function add { }
export function sum { }
export function valid { }

import * as helper from "./filepath";
helper.add();
```

- Empty

```typescript
import 'mocha'; //no export only side effect
describe('shortestPath', () => {});

import 'core-js'; // a common polyfill library
```

### export / const x = require('')

NodeJS - CommonJS Module standard, `module.exports`

export in JS

```JS
exports.equal = function equal
```
in JS

```javascript
const assert = require('assert');
```

To let TS find the type definition file using

```typescript
import * as assert from 'assert';
// or
import { equal } from 'assert';
```

`import/require` for importing **type** only

```typescript
import foo = require('foo');
```

### export / import x = require('')

> `import/require` to import type
>
> `import/from` local module

## Declaration

### declare keyword

`var` creates a new variable.

`declare` opt-out 3rd non-typescript library from the type checking.

> It is used to tell TypeScript that the variable has been created elsewhere. Nothing is added to the JavaScript that is generated - it is simply a **hint to the compiler**.

https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html

### Definition File

> MY TIP: something like `def` file in c/c++, or `header` file

https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html

### Type Declaration


###
