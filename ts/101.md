# TypeScript 101

https://www.typescriptlang.org/docs

## TL;DR
- superset of JS
- interface/class
- import/export
- module/namespace
- public/private
- type : and cast <>

```
module/namespace  --> class  --> fields / constructor / properties / functions
                        |
                        V
                    interface
```

## Types

### Primitive Types
- `boolean`
- `number`
- `string`

### Array

```typescript
let numArr: number [] = [1, 2, 3];
let strArr: string [] = ['hi', 'hey'];

```

### Enum
- same as other lang, starts with 0 by default

```typescript
enum Color { Red = 1, Green, Blue }
let c: Color = Color.Green;
```

### Object
- non-primitive type, i.e. any thing that is not `number`, `string`, `boolean`, `symbol`, `null`, or `undefined`

### Special Types

`any` - **new**
- escape the type system
- opt-out type checking


`undefined` and `null`
- same as javascript
- can assign to any type

### Types for Functions

`never` - **new**
- a **function** that always throws an exception
- no return point in a function

`void` - **new**
- a function that returns nothing

### Type Cast
- `(<string>myAny).length`
- `(myAny as string).length`

### Generic

aka template `Array<T>`,

### Union Type
- multiple types but don't want use `any` instead use `|` to pipe all possible types
- e.g. `function formatCommandline(command: string[]|string)`

### Tuple

```typescript
let x: [number, string];
x = [1, 'Jamie'];
```

### Type Alias

type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) => void;

>TIP: If you need to have hierarchies of Type annotations use an interface. They can be used with implements and extends

>TIP: Use a type alias for simpler object structures (like Coordinates) just to give them a semantic name. Also when you want to give semantic names to Union or Intersection types, a Type alias is the way to go.

`var` or `let`
- `let` block scope
- `let` stop you re declare in the same scope

## Functions

a function returns `never` - return nothing, not even `undefined` or `null`

a function returns `void` - it still can return `undefined` or `null`

>MY TIP: Should always prefer `never` on function return

## Interfaces

a simple data structure, or sub type helping tsc to do the type checking

- property modifiers

```typescript
interface {
    firstname: string;
    lastname: string;
    readonly dob: string; // can never be modified
    nickname? string; // optional

}
```

- How interface help to do the type checking

```typescript
interface IConfig {
    size: number;
}

function foo(config: IConfig) {
    console.log()
}
let ret = foo({ size: 10 } as IConfig); // check the input parameters
```
## Class

- a class extend a interface, like C# Java
- a interface extend another interface

OOP same as other langs
- `static` and `instance`
- `abstract class` // can have impl, only abstract methods to be impl. in derived class
- `public`, `private`, `protected`
- `Readonly`
- `get`, `set` // I have to write my get and set methods, err...

## Module

`export`


`import = require()`